# Генераторы псевдослучайных чисел

Этот репозиторий содержит примеры реализации двух различных генераторов псевдослучайных чисел:
1. Генератор на основе мультиномиального распределения с использованием NumPy.
2. Кубический конгруэнтный генератор (Cubic Congruential Generator).

Ниже приведено описание принципов их работы с примерами кода.

---

## 1. Мультиномиальный генератор (NumPy)
### Принцип работы
Генератор случайной последовательности на основе мультиномиального распределения создает цепочку из n случайных чисел, каждое из которых представляет собой индекс категории, выбранной в соответствии с заданными вероятностями. Это моделирует серию независимых испытаний, где каждое испытание имеет несколько возможных исходов с указанными вероятностями. Функция использует np.random.multinomial для генерации выборок, где каждое испытание представлено как "one-hot" вектор, из которого извлекается индекс выбранной категории.

### Входные данные:
- pvals: список вероятностей для каждой категории (сумма должна быть равна 1).
- n: количество испытаний, то есть длина генерируемой последовательности.
- Выходные данные: одномерный массив длины n, содержащий индексы выбранных категорий (0, 1, 2, ...).
### Пример кода
```python
import numpy as np

def generate_sequence(pvals, n):
    """
    Генерирует цепочку случайных чисел длины n с использованием мультиномиального распределения.

    Параметры:
    pvals (list): Массив вероятностей для каждого исхода. Сумма должна быть равна 1.
    n (int): Длина генерируемой цепочки.

    Возвращает:
    numpy.ndarray: Массив длины n, содержащий индексы исходов (0, 1, 2, ...).
    """
    samples = np.random.multinomial(1, pvals, size=n)
    sequence = np.argmax(samples, axis=1)
    return sequence

# Пример использования
arr = generate_sequence([0.3, 0.7], 10)
print(arr)
```
### Пример вывода
```text
[1 0 1 1 0 1 1 1 0 1]
```
В этом примере сгенерирована последовательность из 10 случайных чисел, где каждое число — это индекс категории, выбранной с вероятностями 0.3 для категории 0 и 0.7 для категории 1. Например, результат показывает, что в 10 испытаниях категории выбирались в следующем порядке: 1, 0, 1, 1, 0, 1, 1, 1, 0, 1.

## 2. Кубический конгруэнтный генератор
### Принцип работы
Кубический конгруэнтный метод — это разновидность линейного конгруэнтного генератора (LCG), где следующее число в последовательности вычисляется по кубическому полиному:

```text
x_{n+1} = (a * x_n³ + b * x_n² + c * x_n + d) mod m
```
### Параметры:
- a, b, c: коэффициенты при x³, x² и x соответственно.
- d: константа (по умолчанию 0).
- m: модуль, обычно выбирается как степень двойки (m = 2^k).
- x0: начальное значение (seed).
### Особенности: 
использование кубической зависимости делает последовательность более сложной и потенциально более "случайной" по сравнению с линейным методом, но требует тщательного подбора параметров для обеспечения хорошего периода и равномерности.
### Пример кода
```python
class CubicCongruentialGenerator:
    def __init__(self, a: int, b: int, c: int, k: int, x0: int, d: int = 0):
        """
        Инициализация кубического конгруэнтного генератора.
        a, b, c - коэффициенты; k - степень для m = 2^k; x0 - начальное значение; d - константа.
        """
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.m = 2 ** k
        self.current = x0

    def next(self) -> int:
        """Генерирует следующее число."""
        self.current = (self.a * self.current**3 + self.b * self.current**2 + 
                       self.c * self.current + self.d) % self.m
        return self.current

    def generate_sequence(self, n: int) -> list:
        """Генерирует последовательность из n чисел."""
        return [self.next() for _ in range(n)]

# Пример использования
generator = CubicCongruentialGenerator(a=1, b=2, c=3, k=10, x0=42)
sequence = generator.generate_sequence(5)
print(sequence)
```
### Пример вывода:

```text
[186, 756, 372, 180, 852]
```
Последовательность зависит от начальных параметров и может быть настроена для конкретных задач.

### Применение
Используется в криптографии, моделировании и тестировании, где требуется детерминированная последовательность псевдослучайных чисел.